## 浏览器知识

* [从输入 `url` 到呈现页面发生了哪些事](#anchor1)
* [ `http2.0` 与 `http1.x` ](#anchor2)
* [ `GET` 和 `POST` 的区别](#anchor3)
* [ `TCP` 与 `UDP` 的区别](#anchor4)
* [ `HTTPS` 与 `HTTP` 的一些区别](#anchor5)
* [ `SPDY` ](#anchor6)
* [事件循环机制](#anchor7)
* [性能优化](#anchor8)
* [跨域请求数据的几种方式](#ancho9)
* [ `localStorage` 、 `sessionStorage` 、 `Cookie` 之间的区别](#ancho10)

<span id="anchor1"></span>

### 从输入 `url` 到呈现页面发生了哪些事

* **DNS 解析**

  首先在本地域名服务器中查询IP地址，如果没有，按照如下顺序
  根域名服务器.-> 顶级域名服务器 `com` -> …… -> 本地域名服务器
  .-> `.com` -> `google.com.` -> `www.google.com.` 

  优化：DNS 缓存
  浏览器缓存 -> 系统缓存 -> 路由器缓存 -> ISP (运营商) DNS 缓存 -> 根域名服务器 -> 顶级域名服务器 `com` -> 主域名服务器的顺序

  浏览器缓存可通过在浏览器输入 `chrome://net-internals/#dns` 查看
  系统缓存在 `/etc/hosts` 文件中（ `linux` 系统）

* **TCP 请求（三次握手）+ HTTP 请求**

  + 客户端：我要请求数据，可以吗
  + 服务器：可以
  + 客户端：好的

  客户机与服务器建立连接后就可以通信，浏览器向web服务器发送http请求

* **浏览器解析渲染页面**

  + 处理 `HTML` 标记并构建 `DOM` 树
  + 处理 `CSS` 标记并构建 `CSSOM` 树。
  + 将 `DOM` 与 `CSSOM` 合并成一个渲染树。
  + 根据渲染树来布局，以计算每个节点的几何信息。
  + 调用 `GPU` 绘制，合成图层，显示在屏幕上

`DOMContentLoaded` 事件触发代表初始的 `HTML` 被完全加载和解析，不需要等待 `CSS` ， `JS` ，图片加载。
`Load` 事件触发代表页面中的 `DOM` ， `CSS` ， `JS` ，图片已经全部加载完毕。

* **连接结束，四次挥手**

  + 客户端：我没要数据要发送了，准备挂了
  + 服务器：收到，但我还有一些数据没发送完，稍等一哈…
  + 服务端：好了，发送完了，可以断开连接了
  + 客户端：OK，你断开连接吧（内心独白：我将会在2倍的最大报文段生存时间后关闭连接，如果再收到服务器的消息，那么服务器就是没听到我最后这句话，我就再发送一遍）。

<span id="anchor2"></span>

### `http2.0` 与 `http1.x` 

* `HTTP1.x` 有以下几个主要缺点：
  + `HTTP/1.0` 一次只允许在一个 `TCP` 连接上发起一个请求， `HTTP/1.1` 使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。
  + 单向请求，只能由客户端发起。
  + 请求报文与响应报文首部信息冗余量大。
  + 数据未压缩，导致数据的传输量大。 
* 相比 `HTTP/1.x` ， `HTTP/2` 在底层传输做了很大的改动和优化：
  + **新的二进制格式（ `Binary Format` ）**， `HTTP1.x` 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 `0` 和 `1` 的组合。基于这种考虑 `HTTP2.0` 的协议解析决定采用二进制格式，实现方便且健壮。
  + **多路复用（ `MultiPlexing` ）**，即连接共享，即每一个 `request` 都是是用作连接共享机制的。一个 `request` 对应一个 id，这样一个连接上可以有多个 `request` ，每个连接的 `request` 可以随机的混杂在一起，接收方可以根据 `request` 的 `id` 将 `request` 再归属到各自不同的服务端请求里面。多路复用原理图：
  + **header压缩**，如上文中所言，对前面提到过 `HTTP1.x` 的 `header` 带有大量信息，而且每次都要重复发送， `HTTP2.0` 使用 `encoder` 来减少需要传输的 `header` 大小，通讯双方各自 `cache` 一份 `header fields` 表，既避免了重复 `header` 的传输，又减小了需要传输的大小。
  + **服务端推送（ `server push` ）**，同 `SPDY` 一样， `HTTP2.0` 也具有 `server push` 功能。目前，有大多数网站已经启用 `HTTP2.0` ，例如 `YouTuBe` ，淘宝网等网站，利用 `chrome` 控制台可以查看是否启用 `H2` 

<span id="anchor3"></span>

### `GET` 和 `POST` 的区别

* `GET` 产生一个 `TCP` 数据包； `POST` 产生两个 `TCP` 数据包。
* `GET` 在浏览器回退时是无害的，而 `POST` 会再次提交请求。
* `GET` 产生的 `URL` 地址可以被 `Bookmark` ，而 `POST` 不可以。
* `GET` 请求会被浏览器主动 `cache` ，而 `POST` 不会，除非手动设置。
* `GET` 请求只能进行 `url` 编码，而 `POST` 支持多种编码方式。
* `GET` 请求参数会被完整保留在浏览器历史记录里，而 `POST` 中的参数不会被保留。
* `GET` 请求在 `URL` 中传送的参数是有长度限制的，而 `POST` 没有。
* 对参数的数据类型， `GET` 只接受 `ASCII` 字符，而 `POST` 没有限制。
* `GET` 比 `POST` 更不安全，因为参数直接暴露在 `URL` 上，所以不能用来传递敏感信息。
* `GET` 参数通过 `URL` 传递， `POST` 放在 `Request body` 中。

<span id="anchor4"></span>

### `TCP` 与 `UDP` 的区别

* TCP

> `TCP/IP` 协议是 `Internet` 最基本的协议、 `Internet` 国际互联网络的基础，由网络层的 `IP` 协议和传输层的 `TCP` 协议组成。通俗而言： `TCP` 负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。

* UDP

> `UDP` 用户数据报协议，是面向无连接的通讯协议， `UDP` 数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。

`TCP` 与 `UDP` 的区别: `TCP` 是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。

<span id="anchor5"></span>

### `HTTPS` 与 `HTTP` 的一些区别

* `HTTPS` 协议需要到 `CA` 申请证书，一般免费证书很少，需要交费。
* `HTTP` 协议运行在 `TCP` 之上，所有传输的内容都是明文， `HTTPS` 运行在 `SSL/TLS` 之上， `SSL/TLS` 运行在 `TCP` 之上，所有传输的内容都经过加密的。
* `HTTP` 和 `HTTPS` 使用的是完全不同的连接方式，用的端口也不一样，前者是 `80` ，后者是 `443` 。
* `HTTPS` 可以有效的防止运营商劫持，解决了防劫持的一个大问题。

<span id="anchor6"></span>

### `SPDY` 

`SPDY` 可以说是综合了 `HTTPS` 和 `HTTP` 两者有点于一体的传输协议，主要解决：

* **降低延迟**，针对 `HTTP` 高延迟的问题， `SPDY` 优雅的采取了多路复用（ `multiplexing` ）。多路复用通过多个请求 `stream` 共享一个 `tcp` 连接的方式，解决了 `HOL blocking` 的问题，降低了延迟同时提高了带宽的利用率。
* **请求优先级（ `request prioritization` ）**。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。 `SPDY` 允许给每个 `request` 设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 `html` 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
* **header压缩**。前面提到 `HTTP1.x` 的 `header` 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。
* **基于 `HTTPS` 的加密协议传输**。大大提高了传输数据的可靠性。
* **服务端推送（ `server push` ）**，采用了 `SPDY` 的网页，例如我的网页有一个 `sytle.css` 的请求，在客户端收到 `sytle.css` 数据的同时，服务端会将 `sytle.js` 的文件推送给客户端，当客户端再次尝试获取 `sytle.js` 时就可以直接从缓存中获取到，不用再发请求了。

<span id="anchor7"></span>

### 事件循环机制

事件循环机制流程：

1. 主线程执行 `JavaScript` 整体代码，形成执行上下文栈，当遇到各种任务源时将其所指定的异步任务挂起，接受到响应结果后将异步任务放入对应的任务队列中，直到执行上下文栈只剩全局上下文；
2. 将微任务队列中的所有任务队列按优先级、单个任务队列的异步任务按先进先出（ `FIFO` ）的方式入栈并执行，直到清空所有的微任务队列；
3. 将宏任务队列中优先级最高的任务队列中的异步任务按先进先出（ `FIFO` ）的方式入栈并执行；
4. 重复第 `2 3` 步骤，直到清空所有的宏任务队列和微任务队列，全局上下文出栈。

简单来说，事件循环机制的流程就是，主线程执行 `JavaScript` 整体代码后将遇到的各个任务源所指定的任务分发到各个任务队列中，然后微任务队列和宏任务队列交替入栈执行直到清空所有的任务队列，全局上下文出栈。

<span id="anchor8"></span>

### 性能优化

1. 资源压缩合并，减小 `http` 请求。
2. 非核心代码异步加载（ `defer` 、 `async` ）
  + `defer` ：在 `HTML` 解析完成之后才会执行。如果是多个，则按照加载的顺序依次执行。使用场景，代码依赖试图是否渲染，如代码高亮，评论框。
  + `async` ：在加载完之后立即执行。如果是多个，执行顺序和加载顺序有关。使用场景，代码与 `DOM` 无关，如统计分析代码
3. 浏览器缓存
4. 使用 `CDN` 
5. `DNS` 预解析

可以通过服务器端发送 `X-DNS-Prefetch-Control` 报头。或是在文档中使用值为 `http-equiv` 的meta标签：

``` html
  <meta http-equiv=“x-dns-prefetch-control” content=“on”>
```

在一些高级浏览器中，页面所有的超链接（ `a` 标签），默认打开了 `DNS` 预解析。但是，如果加了上面这行代码，则表明强制打开浏览器的预解析。
对指定的 `url` 进行 `DNS` 预解析

``` html
<link rel="dns-prefetch" href="http://www.smyhvae.com/">
```

当我们从该 `URL` 请求一个资源时，就不再需要等待 `DNS` 解析的过程。该技术对使用第三方资源特别有用。

<span id="anchor9"></span>

### 跨域请求数据的几种方式

> 由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间有任意一个与当前浏览器的地址不同即为跨域。

1. `JSONP` 动态创建 `script` 标签。

  缺点是只支持 `get` 请求，并且很难判断请求是否失败（一般判断请求响应是否超时）

2. `Proxy` 代理

  这种方式首先将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果发送给前端。

3. `CORS` 跨域

  是现代浏览器提供的一种跨域请求资源的方法，需要通过客户端和服务端的同时支持。整个 `CORS` 通信过程，都是浏览器自动完成的，不需要用户参与。对于开发者来说， `CORS` 通信与同源的 `AJAX` 通信没有差别，代码完全一样。浏览器一旦发现 `AJAX` 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现通信关键是服务器。只要服务器实现了 `CORS` 接口，就可以跨域通信。

<span id="anchor10"></span>

### `localStorage` 、 `sessionStorage` 、 `Cookie` 之间的区别

1. `Cookie` 数据始终在同源的 `http` 请求中携带（即使不需要），即 `cookie` 在浏览器和服务器来回传递。而 `sessionStorage` 和 `localStorage` 不会自动把数据发给服务器，仅在本地保存。 `cookie` 数据还有路径（ `path` ）的概念，可以限制 `cookie` 只属于某个路径下。
2. 存储大小限制不同， `cookie` 的数据不能超过 `4k` ，同时因为每次 `http` 请求都会携带 `cookie` ，所以 `cookie` 只适合保存很小的数据，如会话标识。 `sessionStorage` 和 `localStorage` 虽然也有存储大小的限制，但比 `cookie` 大得多，可以达到 `5m` 或者更大。
3. 数据有效期不同， `sessionStorage` 仅在当前浏览器窗口关闭前有效，自然就不可能永久保持， `localStorage` 始终有效，窗口或者浏览器关闭也一直保存，因此用作持久数据； `cookie` 只在设置的 `cookie` 过期之前一直有效，即使窗口或浏览器关闭。
4. 作用域不同， `sessionstorage` 不在不同的浏览器页面共享，即使在同一个页面； `localstorage` 在所有同源窗口中都是共享的， `cookie` 也是在所有同源窗口中共享的。 `webStorage` 支持事件通知机制，可以将数据更新的通知发给监听者。 `webStorage` 的api接口使用更方便， `cookie` 的原生接口不友好，需要自己封装。

