## JS

### 基本数据类型和引用数据类型

* 基本数据类型： `undefined` 、 `null` 、 `boolean` 、 `number` 、 `symbol` 、 `string` 。
* 引用数据类型： `object` 、 `array` 、 `function` 。

### JavaScript 中的作用域与变量声明提升

* 在 `JavaScript` 中，作用域为 `function(){}` 内的区域，称为函数作用域。
* `JavaScript` 变量声明提升
  + 在 `JavaScript` 中，函数声明与变量声明经常被 `JavaScript` 引擎隐式地提升到当前作用域的顶部。
  + 声明语句中的赋值部分并不会被提升，只有名称被提升。
  + 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明。
  + 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数。

### let、const 与 var 的区别

* 变量提升
* 块级作用域 

### defer 和 async 的区别

* defer：浏览器指示脚本在文档被解析后执行，script被异步加载后并不会立刻执行，而是等待文档被解析完毕后执行。
* async：同样是异步加载脚本，区别是脚本加载完毕后立即执行，这导致async属性下的脚本是乱序的，对于script有先后依赖关系的情况，并不适用。

### 对象浅拷贝和深拷贝有什么区别

在 `JS` 中，除了基本数据类型，还存在对象、数组这种引用类型。 基本数据类型，拷贝是直接拷贝变量的值，而引用类型拷贝的其实是变量的地址。

``` js
let o1 = {
    a: 1
}
let o2 = o1
```

在这种情况下，如果改变 `o1` 或 `o2` 其中一个值的话，另一个也会变，因为它们都指向同一个地址。

``` js
o2.a = 3
console.log(o1.a) // 3
```

而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有重新创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。

### 怎么实现对象深拷贝

``` js
let o1 = {
    a: {
        b: 1
    }
}
let o2 = JSON.parse(JSON.stringify(o1))
```

另一种方法

``` js
function deepCopy(s) {
    const d = {}
    for (let k in s) {
        if (typeof s[k] == 'object') {
            d[k] = deepCopy(s[k])
        } else {
            d[k] = s[k]
        }
    }

    return d
}
```

