## Vue

### 虚拟DOM的实现原理

* 用 `JavaScript` 对象模拟真实的 `DOM` 树，对真实 `DOM` 进行抽象；
* `diff` 算法 - 比较两颗虚拟 `DOM` 树的差异；
* `Pach` 算法 - 将两个虚拟 `DOM` 对象的差异应用到真正的 `DOM` 树。

### 组件中 data 为什么是一个函数

因为组件是用来复用的，且 `JS` 里对象是引用关系，如果组件中 `data` 是一个对象，那么这样作用域没有隔离，子组件中的 `data` 属性值会相互影响，如果组件中 `data` 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 `data` 属性值不会互相影响；而 `new Vue` 的实例，是不会被复用的，因此不存在引用对象的问题。

### Vue 组件间通信有哪几种方式？

1. `props / $emit` 适用父子组件通信：

    这种方法是 `Vue` 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。

2. `ref` 与 `$parent / $children` ：适用父子组件通信
  + `ref` ：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例
  + `$parent / $children` ：访问父 / 子实例
3. `EventBus（$emit / $on）` ：适用于父子、隔代、兄弟组件通信

    这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。

4. `$attrs/$listeners` ：适用于隔代组件通信
  + `$attrs` ：包含了父作用域中不被 `prop` 所识别 (且获取) 的特性绑定 ( `class` 和 `style` 除外 )。当一个组件没有声明任何 `prop` 时，这里会包含所有父作用域的绑定 ( `class` 和 `style` 除外 )，并且可以通过 `v-bind="$attrs"` 传入内部组件。通常配合 `inheritAttrs` 选项一起使用。
  + `$listeners` ：包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件
5. `provide / inject` ：适用于隔代组件通信

    祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。

6. `Vuex` ：适用于父子、隔代、兄弟组件通信。

